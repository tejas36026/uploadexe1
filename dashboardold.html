<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Activity Tracker Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        .app-dashboard-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    border-radius: 15px;
    margin-bottom: 20px;
}

.session-info-detailed {
    margin-top: 15px;
}

.info-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 15px;
}

.content-preview {
    background: rgba(255, 255, 255, 0.1);
    padding: 15px;
    border-radius: 10px;
    margin-top: 15px;
}

.typed-preview, .pasted-preview {
    margin-bottom: 10px;
    font-size: 14px;
}

.app-dashboard-nav {
    display: flex;
    gap: 15px;
    align-items: center;
    background: rgba(255, 255, 255, 0.9);
    padding: 15px;
    border-radius: 10px;
    margin: 15px 0;
}

.nav-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s ease;
}

.back-to-apps {
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
}

.back-to-sessions {
    background: linear-gradient(135deg, #27ae60, #229954);
    color: white;
}

.show-all {
    background: linear-gradient(135deg, #e74c3c, #c0392b);
    color: white;
}

.current-view {
    margin-left: auto;
    font-weight: bold;
    color: #2c3e50;
}

.chart-back-btn {
    position: absolute;
    top: 10px;
    left: 10px;
    background: #3498db;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 20px;
    cursor: pointer;
    font-weight: 600;
    z-index: 10;
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .dashboard {
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }

        .header h1 {
            color: #2c3e50;
            font-size: 28px;
            margin-bottom: 10px;
        }

        .session-info {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .info-item {
            display: flex;
            flex-direction: column;
        }

        .info-label {
            font-size: 12px;
            color: #7f8c8d;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-value {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            color: white;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }

        .btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }

        .chart-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .chart-canvas {
            max-height: 300px;
        }

        .activity-log {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            margin-bottom: 20px;
        }

        .activity-log h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .activity-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 5px 12px;
            border: 2px solid #3498db;
            background: transparent;
            color: #3498db;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .filter-btn.active {
            background: #3498db;
            color: white;
        }

        .activity-item {
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            border-left: 4px solid;
            background: #f8f9fa;
        }

        .activity-item.typed {
            border-left-color: #27ae60;
            background: #d5f4e6;
        }

        .activity-item.pasted {
            border-left-color: #e74c3c;
            background: #fdeaea;
        }

        .activity-item.fast-typing {
            border-left-color: #f39c12;
            background: #fef9e7;
        }

        .activity-item.thoughtful {
            border-left-color: #9b59b6;
            background: #f4ecf7;
        }

        .activity-header {
            display: flex;
            justify-content: space-between;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .activity-content {
            font-size: 14px;
            color: #555;
        }

        .typing-rhythm {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            margin-bottom: 20px;
        }

        .rhythm-canvas {
            width: 100%;
            height: 200px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }

        .stat-number {
            font-size: 32px;
            font-weight: 700;
            color: #3498db;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .text-analysis {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            margin-bottom: 20px;
        }

        .sentence {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 5px;
            line-height: 1.6;
        }

        .sentence.typed {
            background-color: #d5f4e6;
        }

        .sentence.pasted {
            background-color: #fdeaea;
        }

        .sentence.fast {
            background-color: #fff3cd;
        }

        .sentence.thoughtful {
            background-color: #f4ecf7;
        }

        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .session-info {
                flex-direction: column;
                gap: 15px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
        }

        /* Session List Container */
#session-list {
    margin-bottom: 20px;
}

/* Individual Session Item */
.session-item {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 10px;
    padding: 12px 15px;
    margin-bottom: 8px;
    box-shadow: 0 4px 16px 0 rgba(31, 38, 135, 0.2);
    backdrop-filter: blur(4px);
    border: 1px solid rgba(255, 255, 255, 0.18);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.session-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px 0 rgba(31, 38, 135, 0.3);
    border: 1px solid rgba(52, 152, 219, 0.3);
}

.session-item.active {
    border: 2px solid #3498db;
    background: rgba(52, 152, 219, 0.1);
}

.session-item.expanded {
    padding: 15px;
}

.session-item.collapsed {
    display: none;
}

/* Session Header */
.session-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0;
}

.session-item.expanded .session-header {
    margin-bottom: 12px;
}

.session-title {
    font-size: 16px;
    font-weight: 600;
    color: #2c3e50;
    display: flex;
    align-items: center;
    gap: 6px;
}

.session-status {
    font-size: 10px;
    padding: 3px 6px;
    border-radius: 10px;
    background: linear-gradient(135deg, #27ae60, #229954);
    color: white;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.3px;
}

.session-times {
    font-size: 11px;
    color: #7f8c8d;
    text-align: right;
}

.start-time, .end-time {
    margin-bottom: 2px;
}

/* Close Button */
.session-close-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: rgba(231, 76, 60, 0.9);
    color: white;
    border: none;
    cursor: pointer;
    font-size: 14px;
    display: none;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    z-index: 10;
}

.session-item.expanded .session-close-btn {
    display: flex;
}

.session-close-btn:hover {
    background: #e74c3c;
    transform: scale(1.1);
}
/* Session Block Styles */
.session-block {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 15px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
    backdrop-filter: blur(4px);
    border: 1px solid rgba(255, 255, 255, 0.18);
}

.session-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 15px;
    border-radius: 10px;
    margin-bottom: 15px;
    font-weight: bold;
    font-size: 16px;
}

/* Session Apps Container */
.session-apps-container {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 15px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
}

.session-apps-container h3 {
    color: #2c3e50;
    margin-bottom: 20px;
    font-size: 18px;
    border-bottom: 2px solid #3498db;
    padding-bottom: 10px;
}

/* App Item Styles */
.app-item {
    background: #f8f9fa;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 15px;
    border-left: 4px solid #3498db;
    cursor: pointer;
    transition: all 0.3s ease;
}

.app-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
    background: #e8f4fd;
}

.app-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.app-name {
    font-size: 16px;
    font-weight: bold;
    color: #2c3e50;
}

.app-stats {
    display: flex;
    gap: 15px;
    font-size: 12px;
}

.app-activities, .app-duration {
    background: rgba(52, 152, 219, 0.1);
    padding: 4px 8px;
    border-radius: 12px;
    color: #2980b9;
    font-weight: 600;
}

.app-details {
    font-size: 12px;
    color: #666;
    line-height: 1.4;
}

.app-details div {
    margin-bottom: 4px;
}

.no-apps {
    text-align: center;
    color: #7f8c8d;
    font-style: italic;
    padding: 20px;
}

/* Context Group Styles */
.context-group {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    border-left: 4px solid #3498db;
}

.context-header {
    background: rgba(52, 152, 219, 0.1);
    padding: 10px;
    border-radius: 6px;
    margin-bottom: 10px;
    font-size: 14px;
    color: #2c3e50;
}

.context-header strong {
    color: #2980b9;
}

.context-header small {
    color: #7f8c8d;
    font-size: 12px;
}

/* Filter Section Styles */
.filters-section {
    background: rgba(255, 255, 255, 0.95);
    padding: 20px;
    border-radius: 15px;
    margin-bottom: 20px;
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
}

.filters-section h3 {
    color: #2c3e50;
    margin-bottom: 20px;
    font-size: 18px;
}

.filters-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
}

.filter-group {
    display: flex;
    flex-direction: column;
}

.filter-label {
    font-weight: 600;
    color: #2c3e50;
    margin-bottom: 8px;
    font-size: 14px;
}

.date-range {
    display: flex;
    align-items: center;
    gap: 10px;
}

.date-input, .select-input {
    padding: 10px;
    border: 2px solid #e1e8ed;
    border-radius: 8px;
    font-size: 14px;
    transition: border-color 0.3s ease;
    background: white;
}

.date-input:focus, .select-input:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

.filter-actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.btn-secondary {
    background: linear-gradient(135deg, #95a5a6, #7f8c8d);
    color: white;
}

.btn-link {
    background: none;
    border: none;
    color: #3498db;
    text-decoration: underline;
    cursor: pointer;
    font-size: 12px;
    margin-left: 10px;
}

.btn-link:hover {
    color: #2980b9;
}

/* Filter Summary */
.filter-result {
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    color: #2c3e50;
}

/* Loading and Error States */
.loading {
    text-align: center;
    padding: 40px;
    color: #7f8c8d;
    font-size: 16px;
}

.loading::after {
    content: '';
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 2px solid #3498db;
    border-top: 2px solid transparent;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-left: 10px;
}

.error {
    text-align: center;
    padding: 40px;
    color: #e74c3c;
    font-size: 16px;
    background: #ffeaea;
    border-radius: 10px;
    border: 1px solid #e74c3c;
}

/* Tooltip Styles */
[data-tooltip] {
    position: relative;
    cursor: help;
}

[data-tooltip]:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 1000;
    pointer-events: none;
}

[data-tooltip]:hover::before {
    content: '';
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%) translateY(100%);
    border: 5px solid transparent;
    border-top-color: rgba(0, 0, 0, 0.9);
    z-index: 1000;
}

/* Chart Container Enhancements */
.chart-container {
    position: relative;
}

.chart-container .chart-back-btn {
    position: absolute;
    top: 15px;
    left: 15px;
    z-index: 10;
    background: #3498db;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 20px;
    cursor: pointer;
    font-weight: 600;
    font-size: 12px;
    transition: all 0.3s ease;
}

.chart-container .chart-back-btn:hover {
    background: #2980b9;
    transform: translateY(-1px);
}

/* Enhanced Session Stats */
.session-stats {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    flex-wrap: wrap;
}

.session-stats span {
    font-size: 12px;
    color: #34495e;
    font-weight: 500;
    padding: 4px 10px;
    background: rgba(52, 152, 219, 0.1);
    border-radius: 15px;
    border: 1px solid rgba(52, 152, 219, 0.2);
}

/* Responsive Design Enhancements */
@media (max-width: 768px) {
    .filters-grid {
        grid-template-columns: 1fr;
    }
    
    .date-range {
        flex-direction: column;
        align-items: stretch;
    }
    
    .filter-actions {
        flex-direction: column;
    }
    
    .app-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
    }
    
    .app-stats {
        flex-direction: column;
        gap: 8px;
    }
    
    .session-summary {
        flex-direction: column;
        gap: 8px;
    }
}

/* Animation Keyframes */
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes fadeIn {
    0% { opacity: 0; transform: translateY(20px); }
    100% { opacity: 1; transform: translateY(0); }
}

.session-block {
    animation: fadeIn 0.5s ease-out;
}

/* Scrollbar Styling */
.activity-log::-webkit-scrollbar,
.session-apps-container::-webkit-scrollbar {
    width: 8px;
}

.activity-log::-webkit-scrollbar-track,
.session-apps-container::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

.activity-log::-webkit-scrollbar-thumb,
.session-apps-container::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 4px;
}

.activity-log::-webkit-scrollbar-thumb:hover,
.session-apps-container::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}

/* Print Styles */
@media print {
    .controls, .filter-actions, .chart-back-btn {
        display: none !important;
    }
    
    .dashboard {
        background: white !important;
    }
    
    .session-block, .chart-container, .activity-log {
        box-shadow: none !important;
        border: 1px solid #ddd !important;
    }
}
/* Show All Sessions Button */
.show-all-sessions {
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    margin-bottom: 15px;
    transition: all 0.3s ease;
    display: none;
}

.show-all-sessions.visible {
    display: inline-block;
}

.show-all-sessions:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
}

/* Session Stats Row - Compact */
.session-stats {
    display: flex;
    gap: 8px;
    margin-bottom: 6px;
    flex-wrap: wrap;
}

.session-item:not(.expanded) .session-stats {
    display: none;
}

.session-stats span {
    font-size: 11px;
    color: #34495e;
    font-weight: 500;
    padding: 3px 8px;
    background: rgba(52, 152, 219, 0.1);
    border-radius: 12px;
    border: 1px solid rgba(52, 152, 219, 0.2);
}

/* Session Apps and Context - Compact */
.session-apps, .session-context {
    font-size: 11px;
    color: #555;
    margin-bottom: 4px;
    line-height: 1.3;
}

.session-item:not(.expanded) .session-apps,
.session-item:not(.expanded) .session-context {
    display: none;
}

.session-apps strong, .session-context strong {
    color: #2c3e50;
    font-weight: 600;
}

/* Compact View Summary */
.session-summary {
    display: flex;
    align-items: center;
    gap: 15px;
    font-size: 12px;
    color: #666;
    margin-top: 4px;
}

.session-item.expanded .session-summary {
    display: none;
}

.session-summary-item {
    display: flex;
    align-items: center;
    gap: 4px;
}

.session-summary-item span {
    font-weight: 600;
    color: #2c3e50;
}

/* No Sessions Message */
.no-sessions {
    text-align: center;
    padding: 40px 20px;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 15px;
    color: #7f8c8d;
    font-size: 16px;
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
}

/* Responsive Design */
@media (max-width: 768px) {
    .session-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
    }
    
    .session-stats {
        flex-direction: column;
        gap: 8px;
    }
    
    .session-stats span {
        align-self: flex-start;
    }
}

/* Hover Effects */
.session-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(52, 152, 219, 0.1), transparent);
    transition: left 0.6s;
    pointer-events: none;
}

.session-item:hover::before {
    left: 100%;
}

/* Status Icons */
.session-title::before {
    content: attr(data-status-icon);
    font-size: 16px;
    margin-right: 5px;
}

/* Loading State */
.session-item.loading {
    opacity: 0.7;
    pointer-events: none;
}

.session-item.loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin: -10px 0 0 -10px;
    border: 2px solid #3498db;
    border-top: 2px solid transparent;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
    </style>
</head>
<body>
    <div class="dashboard">

        <div class="header">

            <h1>Activity Tracker Dashboard</h1>
            <div class="session-info">
                <div class="info-item">
                    <span class="info-label">Session Duration</span>
                    <span class="info-value" id="sessionDuration">--:--:--</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Total Keystrokes</span>
                    <span class="info-value" id="totalKeystrokes">0</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Words Typed</span>
                    <span class="info-value" id="wordsTyped">0</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Active Applications</span>
                    <span class="info-value" id="activeApps">0</span>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="generatePDF()">Download PDF Report</button>
            <button class="btn btn-success" onclick="refreshData()">Refresh Data</button>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number" id="avgWPM">0</div>
                <div class="stat-label">Avg WPM</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="pasteCount">0</div>
                <div class="stat-label">Paste Events</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="mouseClicks">0</div>
                <div class="stat-label">Mouse Clicks</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="backspaceCount">0</div>
                <div class="stat-label">Corrections</div>
            </div>
        </div>
        <div id="session-list"></div>
        <!-- <div class="charts-grid">
            <div class="chart-container">
                <h3 class="chart-title">Session Overview</h3>
                <canvas id="sessionChart" class="chart-canvas"></canvas>
            </div>
            
        </div> -->
        <!-- <div class="chart-container">
            <h3 class="chart-title">üìä Interactive Session Explorer</h3>
            <canvas id="drillDownChart" class="chart-canvas"></canvas>
        </div> -->
        
        <!-- <div class="chart-container">
            <h3 class="chart-title">App Usage Breakdown</h3>
            <canvas id="appUsageChart" class="chart-canvas"></canvas>
        </div> -->
        <div id="sessions-container"></div>
     
        <div id="content-container">
            <h3>Select a session to view content</h3>
            <div id="session-content"></div>
        </div>
                
            <div class="chart-container">
                <h3 class="chart-title">Activity Over Time</h3>
                <canvas id="activityChart" class="chart-canvas"></canvas>
            </div>
            <div class="chart-container">
                <h3 class="chart-title">Application Usage</h3>
                <canvas id="appChart" class="chart-canvas"></canvas>
            </div>
            <div class="chart-container">
                <h3 class="chart-title">Keystroke Distribution</h3>
                <canvas id="keystrokeChart" class="chart-canvas"></canvas>
            </div>
            <div class="chart-container">
                <h3 class="chart-title">Mouse Movement Heatmap</h3>
                <canvas id="mouseChart" class="chart-canvas"></canvas>
            </div>
        </div>

        <div class="typing-rhythm">
            <h3>Typing Rhythm Pattern</h3>
            <canvas id="rhythmCanvas" class="rhythm-canvas"></canvas>
        </div>

        <div class="text-analysis">
            <h3>Text Analysis & Classification</h3>
            <div id="textContent"></div>
        </div>

        <div class="activity-log">
            <h3>Activity Log</h3>
            <div class="activity-filters">
                <button class="filter-btn active" onclick="filterActivities('all')">All</button>
                <button class="filter-btn" onclick="filterActivities('keystroke')">Keystrokes</button>
                <button class="filter-btn" onclick="filterActivities('mouse')">Mouse</button>
                <button class="filter-btn" onclick="filterActivities('paste')">Paste</button>
            </div>
            <div id="activityList"></div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');
        function debugSessions() {
    console.log('=== SESSION DEBUG ===');
    console.log('Total activities:', allTrackingData.length);
    
    const sessions = groupDataBySession();
    console.log('Sessions found:', Object.keys(sessions).length);
    
    Object.entries(sessions).forEach(([sessionId, session]) => {
        console.log(`${sessionId}:`, {
            activities: session.activities.length,
            start: new Date(session.startTime).toLocaleString(),
            end: new Date(session.endTime).toLocaleString(),
            firstActivitySessionID: session.activities[0]?.sessionID,
            lastActivitySessionID: session.activities[session.activities.length-1]?.sessionID
        });
    });
    

    const ChartManager = {
    charts: {},
    
    // Safely destroy a chart
    destroyChart: function(chartKey) {
        if (this.charts[chartKey]) {
            try {
                // Remove event listeners first
                const chart = this.charts[chartKey];
                if (chart.canvas) {
                    chart.canvas.style.cursor = 'default';
                }
                
                // Destroy the chart
                chart.destroy();
                this.charts[chartKey] = null;
                delete this.charts[chartKey];
                
                // Force garbage collection hint
                if (window.gc) window.gc();
                
            } catch (error) {
                console.error('Error destroying chart:', error);
                this.charts[chartKey] = null;
                delete this.charts[chartKey];
            }
        }
    },
    
    // Clean canvas element
    cleanCanvas: function(canvasId) {
        const canvas = document.getElementById(canvasId);
        if (canvas) {
            // Remove all event listeners
            const newCanvas = canvas.cloneNode(true);
            canvas.parentNode.replaceChild(newCanvas, canvas);
            return newCanvas.getContext('2d');
        }
        return null;
    }
};


    // Check for sessionID inconsistencies
    const uniqueSessionIDs = [...new Set(allTrackingData.map(a => a.sessionID))];
    console.log('Unique sessionIDs in data:', uniqueSessionIDs);
}
        document.addEventListener('DOMContentLoaded', loadSessionList);
        ipcRenderer.on('new-session-saved', loadSessionList);

        async function loadSessionList() {
    const sessions = await ipcRenderer.invoke('get-all-sessions');
    const listElement = document.getElementById('session-list');
    
    // Add show all sessions button
    if (!document.getElementById('showAllSessionsBtn')) {
        const showAllBtn = document.createElement('button');
        showAllBtn.id = 'showAllSessionsBtn';
        showAllBtn.className = 'show-all-sessions';
        showAllBtn.textContent = 'üìã Show All Sessions';
        showAllBtn.onclick = showAllSessions;
        listElement.parentNode.insertBefore(showAllBtn, listElement);
    }
    
    listElement.innerHTML = '';

    if (sessions.length === 0) {
        listElement.innerHTML = '<div class="no-sessions">No sessions recorded yet. Click Start to begin tracking.</div>';
        return;
    }

    sessions.forEach((session, index) => {
        const sessionDiv = document.createElement('div');
        sessionDiv.className = 'session-item';
        sessionDiv.dataset.sessionId = session.id;

        const startTime = new Date(session.startTime);
        const endTime = session.endTime ? new Date(session.endTime) : null;
        const duration = session.duration ? formatDuration(session.duration) : 'Ongoing';
        const totalActivities = session.totalActivities || 0;
        
        const apps = session.apps ? Object.keys(session.apps) : [];
        const appsDisplay = apps.length > 0 ? apps.slice(0, 2).join(', ') + (apps.length > 2 ? ` +${apps.length - 2}` : '') : 'No apps';

        const statusIcon = endTime ? '‚úÖ' : 'üîÑ';
        const statusText = endTime ? 'COMPLETED' : 'ACTIVE';

        sessionDiv.innerHTML = `
            <button class="session-close-btn" onclick="closeSession(event, '${session.id}')">‚úï</button>
            <div class="session-header">
                <div class="session-title">
                    ${statusIcon} <strong>Session #${session.sessionNumber || index + 1}</strong>
                    <span class="session-status">${statusText}</span>
                </div>
                <div class="session-times">
                    <div class="start-time">üïê ${startTime.toLocaleTimeString()}</div>
                    ${endTime ? `<div class="end-time">üèÅ ${endTime.toLocaleTimeString()}</div>` : '<div class="end-time">‚è≥ Running</div>'}
                </div>
            </div>
            
            <!-- Compact summary for collapsed view -->
            <div class="session-summary">
                <div class="session-summary-item">
                    ‚è±Ô∏è <span>${duration}</span>
                </div>
                <div class="session-summary-item">
                    üìä <span>${totalActivities}</span>
                </div>
                <div class="session-summary-item">
                    üì± <span>${apps.length}</span>
                </div>
            </div>
            
            <!-- Detailed view for expanded -->
            <div class="session-stats">
                <span class="duration">‚è±Ô∏è ${duration}</span>
                <span class="activities">üìä ${totalActivities} activities</span>
                <span class="apps-count">üì± ${apps.length} apps</span>
            </div>
            <div class="session-apps">
                <strong>Apps:</strong> ${appsDisplay}
            </div>
            <div class="session-context">
                <strong>Primary:</strong> ${session.mainContext?.appName || 'Unknown'} - ${session.mainContext?.windowTitle || 'Unknown'}
            </div>
        `;

        sessionDiv.addEventListener('click', (e) => {
            // Don't expand if clicking the close button
            if (e.target.classList.contains('session-close-btn')) return;
            
            expandSession(sessionDiv, session);
        });

        listElement.appendChild(sessionDiv);
    });
}
function expandSession(sessionDiv, session) {
    const allSessions = document.querySelectorAll('.session-item');
    const showAllBtn = document.getElementById('showAllSessionsBtn');
    
    // Hide all other sessions
    allSessions.forEach(item => {
        if (item !== sessionDiv) {
            item.classList.add('collapsed');
        }
    });
    
    // Expand clicked session
    sessionDiv.classList.add('expanded', 'active');
    
    // Show the "Show All Sessions" button
    showAllBtn.classList.add('visible');
    
    // Load session data
    displaySessionWithApps(session.id, session.sessionNumber);
}

function closeSession(event, sessionId) {
    event.stopPropagation(); // Prevent session expansion
    
    const sessionDiv = event.target.closest('.session-item');
    const showAllBtn = document.getElementById('showAllSessionsBtn');
    
    // Show all sessions again
    showAllSessions();
}

async function displaySessionWithApps(sessionId, sessionNumber) {
    try {
        const sessionData = await ipcRenderer.invoke('get-session-details', sessionId);
        
        if (!sessionData) {
            console.error('Session not found');
            return;
        }
        
        // Update dashboard header with session number
        const headerTitle = document.querySelector('.header h1');
        const startTime = new Date(sessionData.startTime);
        const endTime = sessionData.endTime ? new Date(sessionData.endTime) : null;
        
        headerTitle.innerHTML = `
            <div>üìã Session #${sessionNumber || sessionData.sessionNumber || 'Unknown'}</div>
            <div style="font-size: 14px; color: #666; margin-top: 5px;">
                üïê ${startTime.toLocaleString()} ${endTime ? `‚Üí ${endTime.toLocaleString()}` : '(Still Active)'} | 
                ‚è±Ô∏è ${formatDuration(sessionData.duration)} | 
                üìä ${sessionData.totalActivities} activities | 
                üì± ${Object.keys(sessionData.apps || {}).length} apps
            </div>
        `;
        
        // Display apps breakdown for this session
        displaySessionApps(sessionData, sessionNumber);
        
        // Update global tracking data with session data
        if (!window.originalTrackingData) {
            window.originalTrackingData = [...allTrackingData];
        }
        
        trackingData = sessionData.activities;
        allTrackingData = sessionData.activities;
        
        updateDashboard();
        addBackToAllSessionsButton();
        
    } catch (error) {
        console.error('Error displaying session:', error);
    }
}
function displaySessionApps(sessionData, sessionNumber) {
    const appsContainer = document.getElementById('session-apps-container') || createAppsContainer();
    appsContainer.innerHTML = `<h3>üì± Applications Used in Session #${sessionNumber || sessionData.sessionNumber || 'Unknown'}</h3>`;
    
    const apps = sessionData.apps || {};
    
    if (Object.keys(apps).length === 0) {
        appsContainer.innerHTML += '<div class="no-apps">No application data available for this session.</div>';
        return;
    }
    
    const sortedApps = Object.values(apps).sort((a, b) => b.totalActivities - a.totalActivities);
    
    sortedApps.forEach((app, index) => {
        const appDiv = document.createElement('div');
        appDiv.className = 'app-item';
        
        const firstActivity = app.activities[0];
        const lastActivity = app.activities[app.activities.length - 1];
        const appDuration = new Date(lastActivity.timestamp) - new Date(firstActivity.timestamp);
        
        // Add ranking
        const rankIcon = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
        
        appDiv.innerHTML = `
            <div class="app-header">
                <div class="app-name">${rankIcon} üì± ${app.name}</div>
                <div class="app-stats">
                    <span class="app-activities">üìä ${app.totalActivities} activities</span>
                    <span class="app-duration">‚è±Ô∏è ${formatDuration(appDuration)}</span>
                </div>
            </div>
            <div class="app-details">
                <div>üïê First seen: ${new Date(firstActivity.timestamp).toLocaleTimeString()}</div>
                <div>üèÅ Last seen: ${new Date(lastActivity.timestamp).toLocaleTimeString()}</div>
                <div>ü™ü Window: ${firstActivity.windowTitle || 'Unknown'}</div>
                ${firstActivity.url && firstActivity.url !== 'N/A' ? `<div>üîó URL: ${firstActivity.url}</div>` : ''}
            </div>
        `;
        
        appDiv.addEventListener('click', () => {
            filterByApp(sessionData.sessionID, app.name, sessionNumber);
        });
        
        appsContainer.appendChild(appDiv);
    });
}


function createAppsContainer() {
    const container = document.createElement('div');
    container.id = 'session-apps-container';
    container.className = 'session-apps-container';
    container.style.cssText = `
        background: rgba(255, 255, 255, 0.95);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
    `;
    
    const dashboard = document.querySelector('.dashboard');
    const statsGrid = document.querySelector('.stats-grid');
    dashboard.insertBefore(container, statsGrid);
    
    return container;
}
function filterByApp(sessionID, appName, sessionNumber) {
    const sessionApps = allTrackingData.filter(activity => 
        activity.sessionID === sessionID && activity.appName === appName
    );
    
    trackingData = sessionApps;
    updateDashboard();
    
    // Update header with session number
    const headerTitle = document.querySelector('.header h1');
    headerTitle.innerHTML = `
        <div>üì± ${appName} in Session #${sessionNumber}</div>
        <div style="font-size: 14px; color: #666; margin-top: 5px;">
            üìã Session ID: ${sessionID} | üìä Activities: ${sessionApps.length}
        </div>
    `;
}



async function displaySession(sessionId) {
    try {
        const sessionData = await ipcRenderer.invoke('get-session-details', sessionId);
        
        if (!sessionData) {
            console.error('Session not found');
            return;
        }
        
        // Store original data for restoration
        if (!window.originalTrackingData) {
            window.originalTrackingData = [...allTrackingData];
        }
        
        // Update global tracking data with session data
        trackingData = sessionData.activities;
        allTrackingData = sessionData.activities;
        
        // Update the entire dashboard with session data
        updateDashboard();
        
        // Update header to show session info
        const headerTitle = document.querySelector('.header h1');
        headerTitle.textContent = `Session: ${new Date(sessionData.startTime).toLocaleString()}`;
        
        // Add back button
        addBackToAllSessionsButton();
        
    } catch (error) {
        console.error('Error displaying session:', error);
    }
}
        
function addBackToAllSessionsButton() {
    const existingBtn = document.getElementById('backToAllBtn');
    if (existingBtn) existingBtn.remove();
    
    const backBtn = document.createElement('button');
    backBtn.id = 'backToAllBtn';
    backBtn.className = 'btn btn-primary';
    backBtn.textContent = 'Back to All Sessions';
    backBtn.onclick = () => {
        if (window.originalTrackingData) {
            allTrackingData = window.originalTrackingData;
            trackingData = window.originalTrackingData;
            delete window.originalTrackingData;
        }
        updateDashboard();
        document.querySelector('.header h1').textContent = 'Activity Tracker Dashboard';
        backBtn.remove();
        
        // Remove active state from session buttons
        document.querySelectorAll('.session-btn.active').forEach(b => b.classList.remove('active'));
    };
    
    document.querySelector('.controls').appendChild(backBtn);
}




        let trackingData = [];        
        let allTrackingData = [];
        let sessionData = null;
        let charts = {};
        let currentFilter = 'all';

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', async () => {
            allTrackingData = await ipcRenderer.invoke('get-tracking-data');

            setupEventListeners();
            debugSessions(); // Add this line

        });
        ipcRenderer.on('session-stopped', (event, data) => {
            allTrackingData = data;
            updateDashboard();
        });


        function setupEventListeners() {
            ipcRenderer.on('activity-update', (event, activity) => {
                trackingData.push(activity);
                updateDashboard();
            });

            ipcRenderer.on('generate-report', (event, data) => {
                sessionData = data;
                updateDashboard();
            });
        }

        async function loadTrackingData() {
            try {
                trackingData = await ipcRenderer.invoke('get-tracking-data');
                updateDashboard();
            } catch (error) {
                console.error('Error loading tracking data:', error);
            }
        }

        function updateDashboard() {
            // console.log('validateTrackingData :>> ', validateTrackingData);

            // renderEnhancedSessionChart();
            updateStats();
            // renderDrillDownSessionChart(); // Add this line

            updateCharts();
            updateActivityLog();
            updateTextAnalysis();
            updateTypingRhythm();
            renderSessions();
// renderAppUsageChart();


trackingData = allTrackingData || []; // Load all session data into trackingData


        }

        function renderDrillDownSessionChart() {
            ChartManager.destroyChart('drillDownChart');

            const ctx = ChartManager.cleanCanvas('drillDownChart');
    if (!ctx) {
        console.error('Could not get canvas context');
        return;
    }

    


    const sessionGroups = groupDataBySession();
    const sessionData = [];
    
    if (!sessionGroups || Object.keys(sessionGroups).length === 0) {
        console.log('No session data available');
        return;
    }

    // Initialize with session-level view  
    let sessionIndex = 1;

    // FIXED: Remove duplicate loop - you had the same loop twice
    for (const sessionID in sessionGroups) {
        const session = sessionGroups[sessionID];
        
        // ADD NULL CHECKS
        if (!session || !session.activities || session.activities.length === 0) {
            continue;
        }
        
        const totalActivities = session.activities.length;
        const duration = calculateSessionDuration(session);
        
        sessionData.push({
            label: `Session ${sessionIndex}`,
            value: totalActivities,
            sessionID: sessionID,
            duration: duration,
            color: getSessionColor(sessionIndex - 1),
            level: 'session'
        });
        sessionIndex++;
    }

    if (sessionData.length === 0) {
        console.log('No valid sessions found');
        return;
    }

    // Store chart state before creating chart
    window.chartDrillState = {
        level: 'session',
        data: sessionData,
        sessionGroups: sessionGroups
    };

    // Create chart with improved error handling
    try {
        charts.drillDownChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: sessionData.map(s => s.label),
                datasets: [{
                    data: sessionData.map(s => s.value),
                    backgroundColor: sessionData.map(s => s.color),
                    borderWidth: 3,
                    borderColor: '#ffffff',
                    hoverBorderWidth: 5,
                    hoverOffset: 20
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'üìä Sessions Overview - Click to Drill Down',
                        font: { size: 18, weight: 'bold' },
                        color: '#2c3e50'
                    },
                    legend: {
                        position: 'bottom',
                        labels: {
                            usePointStyle: true,
                            padding: 20,
                            font: { size: 14 }  
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleColor: '#ffffff',
                        bodyColor: '#ffffff',
                        cornerRadius: 10,
                        padding: 15,
                        callbacks: {
                            title: function(tooltipItems) {
                                if (!tooltipItems || tooltipItems.length === 0) return '';
                                const item = tooltipItems[0];
                                const session = sessionData[item.dataIndex];
                                return session ? `üóÇÔ∏è ${session.label}` : 'Unknown Session';
                            },
                            label: function(context) {
                                if (!context || typeof context.dataIndex === 'undefined') return '';
                                const session = sessionData[context.dataIndex];
                                if (!session) return '';
                                
                                return [
                                    `üìä Activities: ${session.value}`,
                                    `‚è±Ô∏è Duration: ${session.duration}`,
                                    `üñ±Ô∏è Click to view apps breakdown`
                                ];
                            }
                        }
                    }
                },
                
                // Improved onClick handler with better error handling
                onClick: function(event, activeElements) {
                    // Prevent default event handling that might cause conflicts
                    if (event && event.native) {
                        event.native.preventDefault();
                    }
                    
                    try {
                        if (activeElements && activeElements.length > 0) {
                            const elementIndex = activeElements[0].index;
                            
                            // Validate index bounds
                            if (elementIndex >= 0 && elementIndex < sessionData.length) {
                                const selectedSession = sessionData[elementIndex];
                                
                                if (selectedSession && selectedSession.sessionID) {
                                    // Add a small delay to prevent event conflicts
                                    setTimeout(() => {
                                        drillDownToApps(selectedSession);
                                    }, 100);
                                }
                            }
                        }
                    } catch (error) {
                        console.error('Chart click error:', error);
                    }
                },
                // Improved onHover handler
                onHover: function(event, activeElements) {
                    try {
                        const canvas = event.native?.target || ctx.canvas;
                        if (canvas) {
                            canvas.style.cursor = 
                                (activeElements && activeElements.length > 0) ? 'pointer' : 'default';
                        }
                    } catch (error) {
                        console.error('Chart hover error:', error);
                    }
                }
            }
        });

        // Additional safety check
        if (!charts.drillDownChart) {
            console.error('Failed to create chart instance');
            return;
        }

    } catch (error) {
        console.error('Error creating chart:', error);
        // Clean up on error
        if (charts.drillDownChart) {
            charts.drillDownChart.destroy();
            charts.drillDownChart = null;
        }
    }
}
        
   
        




function lightenDarkenColor(col, amt) {
    var usePound = false;
    if (col[0] == "#") {
        col = col.slice(1);
        usePound = true;
    }
    var num = parseInt(col, 16);
    var r = (num >> 16) + amt;
    var g = (num >> 8 & 0x00FF) + amt;
    var b = (num & 0x0000FF) + amt;
    r = r > 255 ? 255 : r < 0 ? 0 : r;
    g = g > 255 ? 255 : g < 0 ? 0 : g;
    b = b > 255 ? 255 : b < 0 ? 0 : b;
    return (usePound ? "#" : "") + (r << 16 | g << 8 | b).toString(16);
}

// Enhanced session analysis view
function showSessionAnalysis(session) {
    const sessionGroups = groupDataBySession();
    const targetSession = sessionGroups[session.sessionID];
    
    // Create detailed analysis popup or section
    createAnalysisModal({
        type: 'session',
        title: `üìä Session ${session.sessionIndex + 1} Analysis`,
        data: targetSession,
        session: session
    });
}



// Create analysis modal/section
function createAnalysisModal(config) {
    // Remove existing modal
    const existingModal = document.getElementById('analysisModal');
    if (existingModal) existingModal.remove();
    
    // Create new modal
    const modal = document.createElement('div');
    modal.id = 'analysisModal';
    modal.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: white; padding: 30px; border-radius: 15px; box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        max-width: 800px; max-height: 80vh; overflow-y: auto; z-index: 1000;
        border: 3px solid ${config.session?.color || config.app?.color || '#4ECDC4'};
    `;
    
    const activities = config.data.activities;
    const startTime = new Date(activities[0]?.timestamp || config.data.startTime);
    const endTime = new Date(activities[activities.length - 1]?.timestamp || Date.now());
    const duration = Math.round((endTime - startTime) / 60000); // minutes
    
    modal.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2 style="color: #333; margin: 0;">${config.title}</h2>
            <button onclick="this.parentElement.parentElement.remove()" style="background: #e74c3c; color: white; border: none; padding: 10px 15px; border-radius: 50%; cursor: pointer; font-size: 16px;">‚úï</button>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
            <div style="background: #f8f9fa; padding: 15px; border-radius: 10px; text-align: center;">
                <div style="font-size: 24px; font-weight: bold; color: #3498db;">${activities.length}</div>
                <div style="color: #666;">Total Activities</div>
            </div>
            <div style="background: #f8f9fa; padding: 15px; border-radius: 10px; text-align: center;">
                <div style="font-size: 24px; font-weight: bold; color: #27ae60;">${duration}m</div>
                <div style="color: #666;">Duration</div>
            </div>
            <div style="background: #f8f9fa; padding: 15px; border-radius: 10px; text-align: center;">
                <div style="font-size: 24px; font-weight: bold; color: #e74c3c;">${startTime.toLocaleTimeString()}</div>
                <div style="color: #666;">Started</div>
            </div>
        </div>
        
        <div style="max-height: 300px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 10px;">
            ${activities.slice(0, 50).map(activity => `
                <div style="background: white; margin-bottom: 8px; padding: 10px; border-radius: 5px; border-left: 4px solid ${activity.type === 'paste' ? '#e74c3c' : '#27ae60'};">
                    <strong>${activity.type === 'paste' ? 'üìã Paste' : '‚å®Ô∏è Type'}:</strong> 
                    ${activity.type === 'paste' ? activity.text?.substring(0, 100) + '...' : activity.key || 'Key'}
                    <br><small style="color: #666;">üì± ${activity.appName} - üïê ${new Date(activity.timestamp).toLocaleTimeString()}</small>
                </div>
            `).join('')}
        </div>
        
        <button onclick="filterAndDisplayReport('${config.session?.sessionID || config.app?.sessionID}', '${config.app?.appName || ''}')" 
                style="background: #3498db; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; margin-top: 15px; width: 100%;">
            üìä Show Full Dashboard for This ${config.type === 'session' ? 'Session' : 'App'}
        </button>
    `;
    
    // Add backdrop
    const backdrop = document.createElement('div');
    backdrop.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;';
    backdrop.onclick = () => { modal.remove(); backdrop.remove(); };
    
    document.body.appendChild(backdrop);
    document.body.appendChild(modal);
}



function filterAndDisplayReport(sessionID, appName = '') {
    // Close any open modals
    const modal = document.getElementById('analysisModal');
    if (modal) modal.remove();
    
    const sessionGroups = groupDataBySession();
    const targetSession = sessionGroups[sessionID];
    
    if (!targetSession) {
        console.error(`Session ${sessionID} not found`);
        return;
    }
    
    let filteredActivities = targetSession.activities;
    
    if (appName && appName !== 'undefined') {
        filteredActivities = targetSession.activities.filter(activity => 
            activity.appName === appName
        );
    }
    
    // Store original data
    if (!window.originalTrackingData) {
        window.originalTrackingData = [...trackingData];
    }
    
    // Update tracking data
    trackingData = filteredActivities;
    
    // Update dashboard
    updateDashboard();
    
    // Update header with better styling
    const headerInfo = document.querySelector('.header h1');
    const sessionStartTime = new Date(targetSession.startTime).toLocaleString();
    
    if (appName && appName !== 'undefined') {
        headerInfo.innerHTML = `üì± ${appName} Analysis<br><small style="font-size: 16px; color: #7f8c8d;">Session: ${sessionStartTime}</small>`;
    } else {
        headerInfo.innerHTML = `üóÇÔ∏è Session Analysis<br><small style="font-size: 16px; color: #7f8c8d;">${sessionStartTime}</small>`;
    }
    
    // Add enhanced return button
    addEnhancedReturnButton();
    
    // Scroll to top
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Enhanced return button
function addEnhancedReturnButton() {
    const existingButton = document.getElementById('showAllSessionsBtn');
    if (existingButton) existingButton.remove();
    
    const button = document.createElement('button');
    button.id = 'showAllSessionsBtn';
    button.innerHTML = 'üîô Show All Sessions';
    button.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white; border: none; padding: 12px 24px; border-radius: 25px;
        cursor: pointer; margin-left: 15px; font-weight: bold;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2); transition: all 0.3s ease;
    `;
    
    button.onmouseover = () => button.style.transform = 'translateY(-2px)';
    button.onmouseout = () => button.style.transform = 'translateY(0)';
    
    button.onclick = () => {
        if (window.originalTrackingData) {
            trackingData = window.originalTrackingData;
            delete window.originalTrackingData;
        }
        updateDashboard();
        document.querySelector('.header h1').textContent = 'Activity Tracker Dashboard';
        button.remove();
        window.scrollTo({ top: 0, behavior: 'smooth' });
    };
    
    document.querySelector('.controls').appendChild(button);
}




function groupDataBySession() {
    if (!allTrackingData || allTrackingData.length === 0) {
        return {};
    }

    // Group by explicit sessionID (from start/stop actions)
    const sessionGroups = {};
    
    allTrackingData.forEach(activity => {
        const activitySessionID = activity.sessionID;
        
        if (!activitySessionID) return; // Skip activities without sessionID
        
        if (!sessionGroups[activitySessionID]) {
            sessionGroups[activitySessionID] = {
                sessionID: activitySessionID,
                activities: [],
                startTime: activity.timestamp,
                endTime: activity.timestamp,
                apps: {}
            };
        }
        
        sessionGroups[activitySessionID].activities.push(activity);
        
        // Update session time bounds
        if (new Date(activity.timestamp) < new Date(sessionGroups[activitySessionID].startTime)) {
            sessionGroups[activitySessionID].startTime = activity.timestamp;
        }
        if (new Date(activity.timestamp) > new Date(sessionGroups[activitySessionID].endTime)) {
            sessionGroups[activitySessionID].endTime = activity.timestamp;
        }
        
        // Group apps within session
        const appName = activity.appName || 'Unknown';
        if (!sessionGroups[activitySessionID].apps[appName]) {
            sessionGroups[activitySessionID].apps[appName] = {
                name: appName,
                activities: [],
                totalActivities: 0
            };
        }
        sessionGroups[activitySessionID].apps[appName].activities.push(activity);
        sessionGroups[activitySessionID].apps[appName].totalActivities++;
    });
    
    return sessionGroups;
}



async function lazyLoadSessionContent(sessionId) {
    // Check if content is already loaded
    if (window.loadedSessions && window.loadedSessions[sessionId]) {
        return window.loadedSessions[sessionId];
    }
    
    try {
        // Load session data from backend
        const sessionData = await ipcRenderer.invoke('get-session-details', sessionId);
        
        if (!sessionData) {
            throw new Error('Session not found');
        }
        
        // Cache the loaded session
        if (!window.loadedSessions) window.loadedSessions = {};
        window.loadedSessions[sessionId] = sessionData;
        
        return sessionData;
    } catch (error) {
        console.error('Error loading session:', error);
        return null;
    }
}

async function displaySession(sessionId) {
    const contentElement = document.getElementById('session-content');
    
    // Show loading state
    contentElement.innerHTML = '<div class="loading">Loading session data...</div>';
    
    try {
        const sessionData = await lazyLoadSessionContent(sessionId);
        
        if (!sessionData) {
            contentElement.innerHTML = '<div class="error">Error: Could not load session data.</div>';
            return;
        }
        
        // Clear previous content and update header
        contentElement.innerHTML = '';
        document.querySelector('#content-container h3').textContent = 
            `Content for session started at ${new Date(sessionData.startTime).toLocaleString()}`;

        // Render session content with better organization
        renderSessionContent(sessionData, contentElement);
        console.log("this is the session");

    } catch (error) {
        contentElement.innerHTML = '<div class="error">Error loading session data.</div>';
        console.error('Session display error:', error);
    }
}

function renderSessionContent(sessionData, container) {
    let currentContext = null;
    let textBuffer = '';
    let contextGroup = document.createElement('div');
    contextGroup.className = 'context-group';
    console.log('sessionData :>> ', sessionData);
    sessionData.activities.forEach((activity, index) => {
        const activityContext = `${activity.appName} - ${activity.windowTitle}`;
        
        // If context changes, finalize current group and start new one
        if (activityContext !== currentContext) {
            if (textBuffer && currentContext) {
                finalizeContextGroup(contextGroup, textBuffer, currentContext);
                container.appendChild(contextGroup);
            }
            
            // Start new context group
            contextGroup = document.createElement('div');
            contextGroup.className = 'context-group';
            contextGroup.setAttribute('data-context', activityContext);
            
            // Add context header
            const contextHeader = document.createElement('div');
            contextHeader.className = 'context-header';
            contextHeader.innerHTML = `
                <strong>üì± ${activity.appName}</strong> - ${activity.windowTitle}
                ${activity.url ? `<br><small>üîó ${activity.url}</small>` : ''}
            `;
            contextGroup.appendChild(contextHeader);
            
            currentContext = activityContext;
            textBuffer = '';
        }
        
        // Process activity
        if (activity.type === 'paste') {
            // Finalize any existing text buffer
            if (textBuffer) {
                addTextSpan(contextGroup, textBuffer, 'typed');
                textBuffer = '';
            }
            // Add pasted content
            addTextSpan(contextGroup, activity.text, 'pasted');
        } else if (activity.type === 'keystroke') {
            const key = activity.key === 'SPACE' ? ' ' : 
                       (activity.key && activity.key.length === 1 ? activity.key : '');
            if (key) textBuffer += key;
        }
        
        // Handle last activity
        if (index === sessionData.activities.length - 1) {
            if (textBuffer) addTextSpan(contextGroup, textBuffer, 'typed');
            container.appendChild(contextGroup);
        }
    });
}

function addTextSpan(container, text, type) {
    const span = document.createElement('span');
    span.className = `sentence ${type}`;
    span.textContent = text;
    container.appendChild(span);
}

function addDateTimeFilters() {
    const filtersSection = document.querySelector('.filters-section') || createFiltersSection();
    
    filtersSection.innerHTML = `
        <h3>üìÖ Filters & Controls</h3>
        <div class="filters-grid">
            <div class="filter-group">
                <label class="filter-label">Date Range</label>
                <div class="date-range">
                    <input type="date" id="startDate" class="date-input">
                    <span>to</span>
                    <input type="date" id="endDate" class="date-input">
                </div>
            </div>
            
            <div class="filter-group">
                <label class="filter-label">Application Filter</label>
                <select id="appFilter" class="select-input">
                    <option value="">All Applications</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label class="filter-label">Session Filter</label>
                <select id="sessionFilter" class="select-input">
                    <option value="">All Sessions</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label class="filter-label">Activity Type</label>
                <select id="activityFilter" class="select-input">
                    <option value="">All Activities</option>
                    <option value="keystroke">Keystrokes Only</option>
                    <option value="paste">Paste Events Only</option>
                    <option value="mouse">Mouse Events Only</option>
                </select>
            </div>
        </div>
        
        <div class="filter-actions">
            <button class="btn btn-primary" onclick="applyFilters()">Apply Filters</button>
            <button class="btn btn-secondary" onclick="clearFilters()">Clear All</button>
            <button class="btn btn-success" onclick="exportFilteredData()">Export Filtered Data</button>
        </div>
    `;
    
    // Populate filter options
    populateFilterOptions();
    
    // Add event listeners
    setupFilterEventListeners();
}

function populateFilterOptions() {
    // Get unique apps
    const apps = [...new Set(allTrackingData.map(d => d.appName))].filter(Boolean);
    const appSelect = document.getElementById('appFilter');
    apps.forEach(app => {
        const option = document.createElement('option');
        option.value = app;
        option.textContent = app;
        appSelect.appendChild(option);
    });
    
    // Get sessions
    const sessions = groupDataBySession();
    const sessionSelect = document.getElementById('sessionFilter');
    Object.entries(sessions).forEach(([sessionId, session]) => {
        const option = document.createElement('option');
        option.value = sessionId;
        option.textContent = `Session ${new Date(session.startTime).toLocaleString()}`;
        sessionSelect.appendChild(option);
    });
}

function applyFilters() {
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    const appFilter = document.getElementById('appFilter').value;
    const sessionFilter = document.getElementById('sessionFilter').value;
    const activityFilter = document.getElementById('activityFilter').value;
    
    let filteredData = [...allTrackingData];
    
    // Apply date filter
    if (startDate || endDate) {
        filteredData = filteredData.filter(activity => {
            const activityDate = new Date(activity.timestamp);
            const start = startDate ? new Date(startDate) : new Date('1900-01-01');
            const end = endDate ? new Date(endDate + 'T23:59:59') : new Date('2100-01-01');
            return activityDate >= start && activityDate <= end;
        });
    }
    
    // Apply app filter
    if (appFilter) {
        filteredData = filteredData.filter(activity => activity.appName === appFilter);
    }
    
    // Apply session filter
    if (sessionFilter) {
        filteredData = filteredData.filter(activity => activity.sessionID === sessionFilter);
    }
    
    // Apply activity type filter
    if (activityFilter) {
        filteredData = filteredData.filter(activity => activity.type === activityFilter);
    }
    
    // Update trackingData and refresh dashboard
    trackingData = filteredData;
    updateDashboard();
    
    // Show filter summary
    showFilterSummary(filteredData.length, allTrackingData.length);
}

function showFilterSummary(filteredCount, totalCount) {
    const summary = document.getElementById('filter-summary') || createFilterSummary();
    summary.innerHTML = `
        <div class="filter-result">
            üìä Showing ${filteredCount.toLocaleString()} of ${totalCount.toLocaleString()} activities
            ${filteredCount < totalCount ? 
                `<button class="btn-link" onclick="clearFilters()">Show All</button>` : ''}
        </div>
    `;
}



function renderDrillDownSessionChart() {
    const ctx = document.getElementById('drillDownChart').getContext('2d');
    if (charts.drillDownChart) {
        charts.drillDownChart.destroy();
    }

    const sessionGroups = groupDataBySession();
    const sessionData = [];
    // console.log('sessionGroups :>> ', sessionGroups);
    if (!sessionGroups || Object.keys(sessionGroups).length === 0) {
        console.log('No session data available');
        return;
    }
    // Initialize with session-level view

    let sessionIndex = 1;


    for (const sessionID in sessionGroups) {
        const session = sessionGroups[sessionID];
        
        // ADD NULL CHECKS
        if (!session || !session.activities || session.activities.length === 0) {
            continue;
        }
        
        const totalActivities = session.activities.length;
        const duration = calculateSessionDuration(session);
        
        sessionData.push({
            label: `Session ${sessionIndex}`,
            value: totalActivities,
            sessionID: sessionID,
            duration: duration,
            color: getSessionColor(sessionIndex - 1),
            level: 'session'
        });
        sessionIndex++;
    }

    if (sessionData.length === 0) {
        console.log('No valid sessions found');
        return;
    }

    
    for (const sessionID in sessionGroups) {
        const session = sessionGroups[sessionID];
        
        // ADD NULL CHECKS
        if (!session || !session.activities || session.activities.length === 0) {
            continue;
        }
        
        const totalActivities = session.activities.length;
        const duration = calculateSessionDuration(session);
        
        sessionData.push({
            label: `Session ${sessionIndex}`,
            value: totalActivities,
            sessionID: sessionID,
            duration: duration,
            color: getSessionColor(sessionIndex - 1),
            level: 'session'
        });
        sessionIndex++;
    }






    charts.drillDownChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: sessionData.map(s => s.label),
            datasets: [{
                data: sessionData.map(s => s.value),
                backgroundColor: sessionData.map(s => s.color),
                borderWidth: 3,
                borderColor: '#ffffff',
                hoverBorderWidth: 5,
                hoverOffset: 20
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'üìä Sessions Overview - Click to Drill Down',
                    font: { size: 18, weight: 'bold' },
                    color: '#2c3e50'
                },
                legend: {
                    position: 'bottom',
                    labels: {
                        usePointStyle: true,
                        padding: 20,
                        font: { size: 14 }  
                    }
                },
                
                tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#ffffff',
                    bodyColor: '#ffffff',
                    cornerRadius: 10,
                    padding: 15,
                    callbacks: {
                        title: function(tooltipItems) {
                            if (!tooltipItems || tooltipItems.length === 0) return '';
                            const item = tooltipItems[0];
                            return `üóÇÔ∏è ${sessionData[item.dataIndex]?.label || 'Unknown Session'}`;
                        },
                        label: function(context) {
                            if (!context || typeof context.dataIndex === 'undefined') return '';
                            const session = sessionData[context.dataIndex];
                            if (!session) return '';
                            
                            return [
                                `üìä Activities: ${session.value}`,
                                `‚è±Ô∏è Duration: ${session.duration}`,
                                `üñ±Ô∏è Click to view apps breakdown`
                            ];
                        }
                    }
                }
            },
            onClick: (event, activeElements) => {
                try {
                    if (activeElements && activeElements.length > 0) {
                        const elementIndex = activeElements[0].index;
                        const selectedSession = sessionData[elementIndex];
                        
                        if (selectedSession) {
                            drillDownToApps(selectedSession);
                        }
                    }
                } catch (error) {
                    console.error('Chart click error:', error);
                }
            },
            onHover: (event, activeElements) => {
                try {
                    if (event && event.native && event.native.target) {
                        event.native.target.style.cursor = 
                            (activeElements && activeElements.length > 0) ? 'pointer' : 'default';
                    }
                } catch (error) {
                    console.error('Chart hover error:', error);
                }
            }
        }
    });



    // Store chart state
    window.chartDrillState = {
        level: 'session',
        data: sessionData,
        sessionGroups: sessionGroups
    };

}

function drillDownToApps(selectedSession) {
    const ctx = document.getElementById('drillDownChart').getContext('2d');
    const sessionGroup = window.chartDrillState.sessionGroups[selectedSession.sessionID];
    if (!window.chartDrillState || !window.chartDrillState.sessionGroups) {
            console.error('Chart drill state not found');
            return;
        }

    // Analyze apps in this session
    const appAnalysis = analyzeSessionApps(sessionGroup);

    console.log('appAnalysis :>> ', appAnalysis);
    if (!appAnalysis || appAnalysis.length === 0) {
            console.error('No apps found in this session');
            return;
        }
        

    const appData = [];
    
    appAnalysis.forEach((app, index) => {
            appData.push({
                label: app.name,
                value: app.activities,
                sessionID: selectedSession.sessionID,
                appName: app.name,
                duration: app.duration,
                typedText: app.typedText || '',
                pastedText: app.pastedText || '',
                color: lightenDarkenColor(selectedSession.color, index * 40 - 80),
                level: 'app'
            });
        });


    // Destroy and recreate chart with app data
    if (charts.drillDownChart) {
            charts.drillDownChart.destroy();
        }
    
  
        

        charts.drillDownChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: appData.map(a => a.label),
                datasets: [{
                    data: appData.map(a => a.value),
                    backgroundColor: appData.map(a => a.color),
                    borderWidth: 3,
                    borderColor: '#ffffff',
                    hoverBorderWidth: 5,
                    hoverOffset: 15
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: `üì± ${selectedSession.label} - Applications Breakdown`,
                        font: { size: 18, weight: 'bold' },
                        color: '#2c3e50'
                    },
                    legend: {
                        position: 'bottom',
                        labels: {
                            usePointStyle: true,
                            padding: 15,
                            font: { size: 12 }
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.9)',
                        titleColor: '#ffffff',
                        bodyColor: '#ffffff',
                        cornerRadius: 10,
                        padding: 15,
                        callbacks: {
                            title: function(tooltipItems) {
                                if (!tooltipItems || tooltipItems.length === 0) return '';
                                const item = tooltipItems[0];
                                return `üì± ${appData[item.dataIndex]?.label || 'Unknown App'}`;
                            },
                            label: function(context) {
                                if (!context || typeof context.dataIndex === 'undefined') return '';
                                const app = appData[context.dataIndex];
                                if (!app) return '';
                                
                                return [
                                    `üìä Activities: ${app.value}`,
                                    `‚è±Ô∏è Duration: ${app.duration}`,
                                    `‚å®Ô∏è Typed: ${(app.typedText || '').substring(0, 50)}${(app.typedText || '').length > 50 ? '...' : ''}`,
                                    `üìã Pasted: ${(app.pastedText || '').substring(0, 50)}${(app.pastedText || '').length > 50 ? '...' : ''}`,
                                    `üñ±Ô∏è Click to view dashboard`
                                ];
                            }
                        }
                    }
                },
                onClick: (event, activeElements) => {
                    try {
                        if (activeElements && activeElements.length > 0) {
                            const elementIndex = activeElements[0].index;
                            const selectedApp = appData[elementIndex];
                            
                            if (selectedApp) {
                                openAppDashboard(selectedApp);
                            }
                        }
                    } catch (error) {
                        console.error('App chart click error:', error);
                    }
                },
                onHover: (event, activeElements) => {
                    try {
                        if (event && event.native && event.native.target) {
                            event.native.target.style.cursor = 
                                (activeElements && activeElements.length > 0) ? 'pointer' : 'default';
                        }
                    } catch (error) {
                        console.error('App chart hover error:', error);
                    }
                }
            }
        });


    // Update chart state and add back button
    window.chartDrillState = {
        level: 'app',
        data: appData,
        parentSession: selectedSession
    };
    
    addChartBackButton();
}

function validateTrackingData() {
    if (!allTrackingData || !Array.isArray(allTrackingData)) {
        console.error('allTrackingData is not a valid array');
        allTrackingData = [];
        return false;
    }
    
    // Filter out invalid entries
    allTrackingData = allTrackingData.filter(activity => 
        activity && 
        activity.timestamp && 
        activity.type && 
        (activity.sessionID || activity.sessionID === 0)
    );
    
    console.log(`Validated ${allTrackingData.length} activities`);
    return allTrackingData.length > 0;
}


function analyzeSessionApps(sessionGroup) {
    const apps = {};
    
    sessionGroup.activities.forEach(activity => {
        const appName = activity.appName || 'Unknown';
        
        if (!apps[appName]) {
            apps[appName] = {
                name: appName,
                activities: 0,
                startTime: new Date(activity.timestamp),
                endTime: new Date(activity.timestamp),
                typedText: '',
                pastedText: ''
            };
        }
        
        apps[appName].activities++;
        apps[appName].endTime = new Date(activity.timestamp);
        
        // Collect text content
        if (activity.type === 'paste') {
            apps[appName].pastedText += activity.text + ' ';
        } else if (activity.type === 'keystroke') {
            const key = activity.key === 'SPACE' ? ' ' : 
                       (activity.key && activity.key.length === 1 ? activity.key : '');
            if (key) apps[appName].typedText += key;
        }
    });
    
    // Calculate durations and clean up text
    return Object.values(apps).map(app => ({
        ...app,
        duration: formatDuration(app.endTime - app.startTime),
        typedText: app.typedText.trim(),
        pastedText: app.pastedText.trim()
    })).sort((a, b) => b.activities - a.activities);
}

function openAppDashboard(selectedApp) {
    // Filter data for this specific app and session
    const filteredData = allTrackingData.filter(activity => 
        activity.sessionID === selectedApp.sessionID && 
        activity.appName === selectedApp.appName
        
    );
    console.log('filteredData :>> ', filteredData);

    if (!filteredData || filteredData.length === 0) {
        console.error('No data found for this app/session combination');
        alert('No data available for this selection');
        return;
    }


    // Store original data for restoration
    if (!window.originalTrackingData) {
        window.originalTrackingData = [...trackingData];
    }
    
    // Update global tracking data
    trackingData = filteredData;
    
    // Calculate session info
    const sessionStart = new Date(filteredData[0].timestamp);
    const sessionEnd = new Date(filteredData[filteredData.length - 1].timestamp);
    console.log('sessionStart.getTime() :>> ', sessionStart.getTime());
    console.log('sessionEnd.getTime() :>> ', sessionEnd.getTime());
    if (isNaN(sessionStart.getTime()) || isNaN(sessionEnd.getTime())) {
        console.error('Invalid timestamps in filtered data');
        return;
    }
    
    // Update dashboard header with specific info
    updateDashboardHeader(selectedApp, sessionStart, sessionEnd);
    
    // Refresh entire dashboard with filtered data
    updateDashboard();
    
    // Add enhanced navigation
    addAppDashboardNavigation(selectedApp);
    
    // Scroll to top
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

function updateDashboardHeader(selectedApp, sessionStart, sessionEnd) {
    const header = document.querySelector('.header');
    header.innerHTML = `
        <div class="app-dashboard-header">
            <h1>üì± ${selectedApp.appName} Dashboard</h1>
            <div class="session-info-detailed">
                <div class="info-row">
                    <div class="info-item">
                        <span class="info-label">Session</span>
                        <span class="info-value">${window.chartDrillState.parentSession.label}</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Date</span>
                        <span class="info-value">${sessionStart.toLocaleDateString()}</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Time Range</span>
                        <span class="info-value">${sessionStart.toLocaleTimeString()} - ${sessionEnd.toLocaleTimeString()}</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Duration</span>
                        <span class="info-value">${formatDuration(sessionEnd - sessionStart)}</span>
                    </div>
                </div>
                <div class="content-preview">
                    <div class="typed-preview">
                        <strong>‚å®Ô∏è Typed Content:</strong>
                        <span>${selectedApp.typedText.substring(0, 100)}${selectedApp.typedText.length > 100 ? '...' : ''}</span>
                    </div>
                    <div class="pasted-preview">
                        <strong>üìã Pasted Content:</strong>
                        <span>${selectedApp.pastedText.substring(0, 100)}${selectedApp.pastedText.length > 100 ? '...' : ''}</span>
                    </div>
                </div>
            </div>
        </div>
    `;
}

function addAppDashboardNavigation(selectedApp) {
    const controls = document.querySelector('.controls');
    
    // Remove existing navigation if present
    const existingNav = document.getElementById('appDashboardNav');
    if (existingNav) existingNav.remove();
    
    const navigation = document.createElement('div');
    navigation.id = 'appDashboardNav';
    navigation.className = 'app-dashboard-nav';
    navigation.innerHTML = `
        <button class="nav-btn back-to-apps" onclick="backToAppsView()">
            ‚Üê Back to Apps
        </button>
        <button class="nav-btn back-to-sessions" onclick="backToSessionsView()">
            ‚Üê Back to Sessions
        </button>
        <button class="nav-btn show-all" onclick="showAllSessions()">
            üè† Show All Data
        </button>
        <div class="current-view">
            üìç Viewing: ${selectedApp.appName} in ${window.chartDrillState.parentSession.label}
        </div>
    `;
    
    controls.appendChild(navigation);
}

function addChartBackButton() {
    const chartContainer = document.getElementById('drillDownChart').parentElement;
    
    // Remove existing back button
    const existingBtn = chartContainer.querySelector('.chart-back-btn');
    if (existingBtn) existingBtn.remove();
    
    const backButton = document.createElement('button');
    backButton.className = 'chart-back-btn';
    backButton.innerHTML = '‚Üê Back to Sessions';
    backButton.onclick = backToSessionsView;
    
    chartContainer.insertBefore(backButton, chartContainer.firstChild);
}

function backToAppsView() {
    if (window.chartDrillState.parentSession) {
        drillDownToApps(window.chartDrillState.parentSession);
    }
}

function backToSessionsView() {
    renderDrillDownSessionChart();
    
    // Remove app dashboard navigation
    const nav = document.getElementById('appDashboardNav');
    if (nav) nav.remove();
    
    // Restore original header
    const header = document.querySelector('.header');
    header.innerHTML = `
        <h1>Activity Tracker Dashboard</h1>
        <div class="session-info">
            <div class="info-item">
                <span class="info-label">Session Duration</span>
                <span class="info-value" id="sessionDuration">--:--:--</span>
            </div>
            <div class="info-item">
                <span class="info-label">Total Keystrokes</span>
                <span class="info-value" id="totalKeystrokes">0</span>
            </div>
            <div class="info-item">
                <span class="info-label">Words Typed</span>
                <span class="info-value" id="wordsTyped">0</span>
            </div>
            <div class="info-item">
                <span class="info-label">Active Applications</span>
                <span class="info-value" id="activeApps">0</span>
            </div>
        </div>
    `;
}


function showAllSessions() {
    const allSessions = document.querySelectorAll('.session-item');
    const showAllBtn = document.getElementById('showAllSessionsBtn');
    
    // Show all sessions
    allSessions.forEach(item => {
        item.classList.remove('collapsed', 'expanded', 'active');
    });
    
    // Hide the "Show All Sessions" button
    showAllBtn.classList.remove('visible');
    
    // Restore original data if needed
    if (window.originalTrackingData) {
        allTrackingData = window.originalTrackingData;
        trackingData = window.originalTrackingData;
        delete window.originalTrackingData;
    }
    
    // Update dashboard to show all data
    updateDashboard();
    
    // Reset header
    const headerTitle = document.querySelector('.header h1');
    headerTitle.textContent = 'Activity Tracker Dashboard';
    
    // Remove any existing back buttons
    const backBtn = document.getElementById('backToAllBtn');
    if (backBtn) backBtn.remove();
    
    // Remove app dashboard navigation
    const nav = document.getElementById('appDashboardNav');
    if (nav) nav.remove();
}


// Helper functions
function calculateSessionDuration(session) {
    const start = new Date(session.startTime);
    const end = new Date(session.endTime);
    return formatDuration(end - start);
}


function formatDuration(milliseconds) {
    if (!milliseconds || milliseconds < 0) return '0s';
    
    const seconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    if (hours > 0) {
        return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
    } else if (minutes > 0) {
        return `${minutes}m ${seconds % 60}s`;
    } else {
        return `${seconds}s`;
    }
}


function getSessionColor(index) {
    const colors = [
        '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', 
        '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'
    ];
    return colors[index % colors.length];
}

function lightenDarkenColor(col, amt) {
    var usePound = false;
    if (col[0] == "#") {
        col = col.slice(1);
        usePound = true;
    }
    var num = parseInt(col, 16);
    var r = (num >> 16) + amt;
    var g = (num >> 8 & 0x00FF) + amt;
    var b = (num & 0x0000FF) + amt;
    r = r > 255 ? 255 : r < 0 ? 0 : r;
    g = g > 255 ? 255 : g < 0 ? 0 : g;
    b = b > 255 ? 255 : b < 0 ? 0 : b;
    return (usePound ? "#" : "") + (r << 16 | g << 8 | b).toString(16);
}

function adjustColorBrightness(color, amount) {
    const usePound = color[0] === "#";
    const col = usePound ? color.slice(1) : color;
    const num = parseInt(col, 16);
    let r = (num >> 16) + amount;
    let g = (num >> 8 & 0x00FF) + amount;
    let b = (num & 0x0000FF) + amount;
    r = r > 255 ? 255 : r < 0 ? 0 : r;
    g = g > 255 ? 255 : g < 0 ? 0 : g;
    b = b > 255 ? 255 : b < 0 ? 0 : b;
    return (usePound ? "#" : "") + String("000000" + (r << 16 | g << 8 | b).toString(16)).slice(-6);
}



        function updateStats() {
            console.log('trackingData :>> ', trackingData);
            const keystrokes = trackingData.filter(d => d.type === 'keystroke');
            const mouseEvents = trackingData.filter(d => d.type === 'mouse');
            const apps = [...new Set(trackingData.map(d => d.appName))];
            
            document.getElementById('totalKeystrokes').textContent = keystrokes.length;
            document.getElementById('activeApps').textContent = apps.length;
            document.getElementById('mouseClicks').textContent = mouseEvents.length;
            
            // Calculate words typed
            const words = calculateWordsTyped(keystrokes);
            document.getElementById('wordsTyped').textContent = words;
            
            // Calculate average WPM
            if (sessionData && sessionData.startTime && sessionData.endTime) {
                const duration = (new Date(sessionData.endTime) - new Date(sessionData.startTime)) / 60000; // minutes
                const wpm = Math.round(words / duration);
                document.getElementById('avgWPM').textContent = isNaN(wpm) ? 0 : wpm;
                
                // Update session duration
                const hours = Math.floor(duration / 60);
                const minutes = Math.floor(duration % 60);
                const seconds = Math.floor((duration % 1) * 60);
                document.getElementById('sessionDuration').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Count paste events and backspaces
            const pasteEvents = keystrokes.filter(k => k.key && k.key.includes('V') && k.ctrlKey).length;
            const backspaces = keystrokes.filter(k => k.key === 'BACKSPACE' || k.key === 'DELETE').length;
            
            document.getElementById('pasteCount').textContent = pasteEvents;
            document.getElementById('backspaceCount').textContent = backspaces;
        }

        function calculateWordsTyped(keystrokes) {
            let text = '';
            keystrokes.forEach(k => {
                if (k.key && k.key.length === 1 && k.key.match(/[a-zA-Z0-9\s]/)) {
                    text += k.key;
                } else if (k.key === 'SPACE') {
                    text += ' ';
                }
            });
            return text.trim().split(/\s+/).filter(word => word.length > 0).length;
        }

        function renderSessions() {
            const sessionsContainer = document.getElementById('sessions-container');
            sessionsContainer.innerHTML = '<h2>Session Activity</h2>'; // Clear and add header

            const sessions = groupDataBySession();

            for (const sessionID in sessions) {
                const session = sessions[sessionID];
                const sessionBlock = document.createElement('div');
                sessionBlock.className = 'session-block';

                const sessionHeader = document.createElement('div');
                sessionHeader.className = 'session-header';
                const startTime = new Date(session.startTime).toLocaleString();
                sessionHeader.textContent = `Session started at: ${startTime}`;
                sessionBlock.appendChild(sessionHeader);
                
                let currentContext = null;
                let textBuffer = '';

                session.activities.forEach((activity, index) => {
                    const activityContext = `${activity.appName} - ${activity.windowTitle}\nURL: ${activity.url || 'N/A'}`;

                    // If context changes, render the previous buffer and start a new one
                    if (activityContext !== currentContext && textBuffer) {
                        const span = document.createElement('span');
                        span.className = currentContext.includes('pasted') ? 'sentence pasted' : 'sentence typed';
                        span.textContent = textBuffer;
                        span.dataset.tooltip = currentContext.replace(' pasted', '');
                        sessionBlock.appendChild(span);
                        textBuffer = '';
                    }
                    
                    currentContext = activityContext + (activity.type === 'paste' ? ' pasted' : '');
                    
                    if (activity.type === 'paste') {
                        // If there was typed text before, render it
                         if (textBuffer) {
                             const typedSpan = document.createElement('span');
                             typedSpan.className = 'sentence typed';
                             typedSpan.textContent = textBuffer;
                             typedSpan.dataset.tooltip = currentContext.replace(' pasted', '');
                             sessionBlock.appendChild(typedSpan);
                             textBuffer = '';
                         }
                        // Render the pasted text immediately
                        const pasteSpan = document.createElement('span');
                        pasteSpan.className = 'sentence pasted';
                        pasteSpan.textContent = activity.text;
                        pasteSpan.dataset.tooltip = activityContext;
                        sessionBlock.appendChild(pasteSpan);

                    } else if (activity.type === 'keystroke') {
                        const key = activity.key === 'SPACE' ? ' ' : (activity.key?.length === 1 ? activity.key : '');
                        textBuffer += key;
                    }

                    // Render any remaining buffer at the end of the loop
                    if (index === session.activities.length - 1 && textBuffer) {
                        const span = document.createElement('span');
                        span.className = 'sentence typed';
                        span.textContent = textBuffer;
                        span.dataset.tooltip = currentContext;
                        sessionBlock.appendChild(span);
                    }
                });

                sessionsContainer.appendChild(sessionBlock);
            }
        }

        function renderAppUsageChart() {
            const ctx = document.getElementById('appUsageChart').getContext('2d');
            if (charts.appUsageChart) {
                charts.appUsageChart.destroy();
            }

            // <<< NEW: Data processing for multi-level chart
            const usageData = {};
            allTrackingData.forEach(act => {
                if (!usageData[act.appName]) {
                    usageData[act.appName] = { count: 0, titles: {} };
                }
                usageData[act.appName].count++;
                
                if (!usageData[act.appName].titles[act.windowTitle]) {
                    usageData[act.appName].titles[act.windowTitle] = 0;
                }
                usageData[act.appName].titles[act.windowTitle]++;
            });

            console.log('allTrackingData :>> ', allTrackingData);
            const appLabels = Object.keys(usageData);
            const appCounts = appLabels.map(app => usageData[app].count);

            const titleLabels = [];
            const titleCounts = [];
            const titleColors = [];

            const baseColors = ['#36A2EB', '#FF6384', '#FF9F40', '#4BC0C0', '#9966FF', '#FFCD56'];

            appLabels.forEach((appName, index) => {
                const titles = usageData[appName].titles;
                const appColor = baseColors[index % baseColors.length];
                let colorIndex = 0;
                for (const title in titles) {
                    titleLabels.push(title);
                    titleCounts.push(titles[title]);
                    // Generate shades for sub-categories
                    titleColors.push(appColor + (99 - (colorIndex * 15)).toString()); 
                    colorIndex++;
                }
            });

console.log('appLabels :>> ', appLabels);
            charts.appUsageChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
        labels: appLabels, // Ensure top-level labels
        datasets: [
            {
                label: 'Applications',
                data: appCounts,
                backgroundColor: baseColors,
                labels: appLabels // Add labels to dataset
            },
            {
                label: 'Window Titles',
                data: titleCounts,
                backgroundColor: titleColors,
                labels: titleLabels // Already correct
            }
        ]
    },
    options: {
        responsive: true,
        plugins: {
            legend: { position: 'top' },
            tooltip: {
                callbacks: {
                    label: function(context) {
                        const dataset = context.dataset;
                        let label = dataset.labels[context.dataIndex] || context.label || '';
                        if (label) {
                            label += ': ';
                        }
                        label += context.parsed;
                        return label;
                    }
                }
            }
        }
    }
});
      
        }
        function updateCharts() {
            updateActivityChart();
            updateAppChart();
            updateKeystrokeChart();
            updateMouseChart();
        }

        function updateActivityChart() {
            const ctx = document.getElementById('activityChart').getContext('2d');
            
            if (charts.activityChart) {
                charts.activityChart.destroy();
            }
            
            // Group activities by time intervals (5-minute intervals)
            const timeGroups = {};
            trackingData.forEach(activity => {
                const time = new Date(activity.timestamp);
                const interval = Math.floor(time.getMinutes() / 5) * 5;
                const key = `${time.getHours()}:${interval.toString().padStart(2, '0')}`;
                
                if (!timeGroups[key]) {
                    timeGroups[key] = { keystrokes: 0, mouse: 0 };
                }
                
                if (activity.type === 'keystroke') {
                    timeGroups[key].keystrokes++;
                } else if (activity.type === 'mouse') {
                    timeGroups[key].mouse++;
                }
            });
            
            const labels = Object.keys(timeGroups).sort();
            const keystrokeData = labels.map(label => timeGroups[label].keystrokes);
            const mouseData = labels.map(label => timeGroups[label].mouse);
            
            charts.activityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Keystrokes',
                        data: keystrokeData,
                        borderColor: '#3498db',
                        backgroundColor: 'rgba(52, 152, 219, 0.1)',
                        tension: 0.4
                    }, {
                        label: 'Mouse Events',
                        data: mouseData,
                        borderColor: '#e74c3c',
                        backgroundColor: 'rgba(231, 76, 60, 0.1)',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function updateAppChart() {
            const ctx = document.getElementById('appChart').getContext('2d');
            
            if (charts.appChart) {
                charts.appChart.destroy();
            }
            
            // Count activities by application
            const appCounts = {};
            trackingData.forEach(activity => {
                const app = activity.appName || 'Unknown';
                appCounts[app] = (appCounts[app] || 0) + 1;
            });
            
            const sortedApps = Object.entries(appCounts)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10); // Top 10 apps
            
            const labels = sortedApps.map(([app]) => app);
            const data = sortedApps.map(([,count]) => count);
            const colors = [
                '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6',
                '#1abc9c', '#34495e', '#f1c40f', '#e67e22', '#95a5a6'
            ];
            
            charts.appChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        function updateKeystrokeChart() {
            const ctx = document.getElementById('keystrokeChart').getContext('2d');
            
            if (charts.keystrokeChart) {
                charts.keystrokeChart.destroy();
            }
            
            const keystrokes = trackingData.filter(d => d.type === 'keystroke');
            const keyCounts = {};
            
            keystrokes.forEach(k => {
                const key = k.key || 'Unknown';
                if (key.length === 1 && key.match(/[a-zA-Z]/)) {
                    keyCounts[key.toUpperCase()] = (keyCounts[key.toUpperCase()] || 0) + 1;
                }
            });
            
            const sortedKeys = Object.entries(keyCounts)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 15);
            
            const labels = sortedKeys.map(([key]) => key);
            const data = sortedKeys.map(([,count]) => count);
            
            charts.keystrokeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Frequency',
                        data: data,
                        backgroundColor: '#3498db',
                        borderColor: '#2980b9',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function updateMouseChart() {
            const ctx = document.getElementById('mouseChart').getContext('2d');
            
            if (charts.mouseChart) {
                charts.mouseChart.destroy();
            }
            
            const mouseEvents = trackingData.filter(d => d.type === 'mouse');
            
            // Create a simple scatter plot for mouse positions
            const scatterData = mouseEvents.map(event => ({
                x: event.x,
                y: event.y
            }));
            
            charts.mouseChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Mouse Positions',
                        data: scatterData,
                        backgroundColor: 'rgba(231, 76, 60, 0.5)',
                        borderColor: '#e74c3c',
                        pointRadius: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'X Position'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Y Position'
                            }
                        }
                    }
                }
            });
        }

        function updateActivityLog() {
            const activityList = document.getElementById('activityList');
            let filteredData = trackingData;
            
            if (currentFilter !== 'all') {
                filteredData = trackingData.filter(activity => {
                    if (currentFilter === 'paste') {
                        return activity.type === 'keystroke' && activity.key && activity.key.includes('V');
                    }
                    return activity.type === currentFilter;
                });
            }
            
            // Show only last 50 activities for performance
            const recentActivities = filteredData.slice(-50).reverse();
            
            activityList.innerHTML = recentActivities.map(activity => {
                const time = new Date(activity.timestamp).toLocaleTimeString();
                const className = getActivityClass(activity);
                
                return `
                    <div class="activity-item ${className}">
                        <div class="activity-header">
                            <span>${activity.type === 'keystroke' ? 'Key: ' + (activity.key || 'Unknown') : 'Mouse'}</span>
                            <span>${time}</span>
                        </div>
                        <div class="activity-content">
                            App: ${activity.appName || 'Unknown'} | 
                            Window: ${activity.windowTitle || 'Unknown'}
                            ${activity.url ? ` | URL: ${activity.url}` : ''}
                            ${activity.x !== undefined ? ` | Position: (${activity.x}, ${activity.y})` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getActivityClass(activity) {
            if (activity.type === 'keystroke') {
                if (activity.key && activity.key.includes('V')) {
                    return 'pasted';
                }
                // You can add more logic here for fast typing detection
                return 'typed';
            }
            return '';
        }

        function updateTextAnalysis() {
            const textContent = document.getElementById('textContent');
            
            // Reconstruct text from keystrokes
            const keystrokes = trackingData.filter(d => d.type === 'keystroke');
            let reconstructedText = '';
            let sentences = [];
            let currentSentence = '';
            textContent.innerHTML = ''; // Clear the display first

            let textBuffer = '';
let currentType = 'typed';

trackingData.forEach((activity, index) => {
    if (activity.type === 'paste') {
        // Flush any existing buffer first
        if (textBuffer) {
            const span = document.createElement('span');
            span.className = `sentence ${currentType}`;
            span.textContent = textBuffer;
            textContent.appendChild(span);
            textBuffer = '';
        }
        // Add pasted content
        const span = document.createElement('span');
        span.className = 'sentence pasted';
        span.textContent = activity.text;
        textContent.appendChild(span);
    } else if (activity.type === 'keystroke') {
        const key = activity.key === 'SPACE' ? ' ' : (activity.key?.length === 1 ? activity.key : '');
        if (key) {
            textBuffer += key;
            currentType = 'typed';
        }
    }
    
    // Flush buffer at the end
    if (index === trackingData.length - 1 && textBuffer) {
        const span = document.createElement('span');
        span.className = `sentence ${currentType}`;
        span.textContent = textBuffer;
        textContent.appendChild(span);
    }
});

        
            if (currentSentence.trim()) {
                sentences.push({
                    text: currentSentence.trim(),
                    type: 'typed'
                });
            }
            
        }

        function updateTypingRhythm() {
            const canvas = document.getElementById('rhythmCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const keystrokes = trackingData.filter(d => d.type === 'keystroke');
            
            if (keystrokes.length < 2) return;
            
            // Calculate intervals between keystrokes
            const intervals = [];
            for (let i = 1; i < keystrokes.length; i++) {
                const interval = new Date(keystrokes[i].timestamp) - new Date(keystrokes[i-1].timestamp);
                intervals.push(interval);
            }
            
            // Draw rhythm pattern
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const maxInterval = Math.max(...intervals);
            const width = canvas.width;
            const height = canvas.height;
            
            intervals.forEach((interval, index) => {
                const x = (index / intervals.length) * width;
                const y = height - (interval / maxInterval) * height;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Add baseline
            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function filterActivities(filter) {
            currentFilter = filter;
            
            // Update filter buttons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            updateActivityLog();
        }

        function refreshData() {
            loadTrackingData();
        }

        function generatePDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Add title
            doc.setFontSize(20);
            doc.text('Activity Tracker Report', 20, 30);
            
            // Add session info
            doc.setFontSize(12);
            let yPos = 50;
            
            if (sessionData) {
                doc.text(`Session Start: ${new Date(sessionData.startTime).toLocaleString()}`, 20, yPos);
                yPos += 10;
                if (sessionData.endTime) {
                    doc.text(`Session End: ${new Date(sessionData.endTime).toLocaleString()}`, 20, yPos);
                    yPos += 10;
                }
            }
            
            // Add statistics
            const stats = [
                `Total Keystrokes: ${document.getElementById('totalKeystrokes').textContent}`,
                `Words Typed: ${document.getElementById('wordsTyped').textContent}`,
                `Average WPM: ${document.getElementById('avgWPM').textContent}`,
                `Active Applications: ${document.getElementById('activeApps').textContent}`,
                `Paste Events: ${document.getElementById('pasteCount').textContent}`,
                `Corrections: ${document.getElementById('backspaceCount').textContent}`
            ];
            
            yPos += 10;
            doc.text('Statistics:', 20, yPos);
            yPos += 10;
            
            stats.forEach(stat => {
                doc.text(stat, 25, yPos);
                yPos += 8;
            });
            
            // Add activity summary
            yPos += 10;
            doc.text('Activity Summary:', 20, yPos);
            yPos += 10;
            
            const appCounts = {};
            trackingData.forEach(activity => {
                const app = activity.appName || 'Unknown';
                appCounts[app] = (appCounts[app] || 0) + 1;
            });
            
            Object.entries(appCounts).slice(0, 10).forEach(([app, count]) => {
                doc.text(`${app}: ${count} activities`, 25, yPos);
                yPos += 8;
                if (yPos > 280) {
                    doc.addPage();
                    yPos = 30;
                }
            });
            
            // Save the PDF
            const filename = `activity_report_${Date.now()}.pdf`;
            doc.save(filename);
        }


        function finalizeContextGroup(contextGroup, textBuffer, currentContext) {
    if (textBuffer.trim()) {
        const span = document.createElement('span');
        span.className = `sentence ${currentContext.includes('pasted') ? 'pasted' : 'typed'}`;
        span.textContent = textBuffer.trim();
        span.dataset.tooltip = currentContext.replace(' pasted', '');
        contextGroup.appendChild(span);
    }
}

function createFiltersSection() {
    const filtersSection = document.createElement('div');
    filtersSection.className = 'filters-section';
    filtersSection.style.cssText = `
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border-radius: 15px;
        margin-bottom: 20px;
        box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
    `;
    document.querySelector('.dashboard').insertBefore(filtersSection, document.querySelector('.stats-grid'));
    return filtersSection;
}

function createFilterSummary() {
    const summary = document.createElement('div');
    summary.id = 'filter-summary';
    summary.style.cssText = `
        padding: 10px;
        background: #f8f9fa;
        border-radius: 8px;
        margin-bottom: 15px;
        text-align: center;
        color: #333;
    `;
    document.querySelector('.dashboard').insertBefore(summary, document.querySelector('.stats-grid'));
    return summary;
}

function clearFilters() {
    document.getElementById('startDate').value = '';
    document.getElementById('endDate').value = '';
    document.getElementById('appFilter').value = '';
    document.getElementById('sessionFilter').value = '';
    document.getElementById('activityFilter').value = '';
    trackingData = [...allTrackingData];
    updateDashboard();
    showFilterSummary(trackingData.length, allTrackingData.length);
}

function exportFilteredData() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    
    doc.setFontSize(20);
    doc.text('Filtered Activity Report', 20, 30);
    
    let yPos = 50;
    doc.setFontSize(12);
    doc.text(`Filtered Activities: ${trackingData.length}`, 20, yPos);
    yPos += 10;
    
    const appCounts = {};
    trackingData.forEach(activity => {
        const app = activity.appName || 'Unknown';
        appCounts[app] = (appCounts[app] || 0) + 1;
    });
    
    doc.text('Applications:', 20, yPos);
    yPos += 10;
    Object.entries(appCounts).forEach(([app, count]) => {
        doc.text(`${app}: ${count} activities`, 25, yPos);
        yPos += 8;
        if (yPos > 280) {
            doc.addPage();
            yPos = 30;
        }
    });
    
    doc.save(`filtered_activity_report_${Date.now()}.pdf`);
}

function setupFilterEventListeners() {
    const inputs = ['startDate', 'endDate', 'appFilter', 'sessionFilter', 'activityFilter'];
    inputs.forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.addEventListener('change', applyFilters);
        }
    });
}
    </script>
</body>
</html>